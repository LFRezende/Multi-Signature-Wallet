{
  "language": "Solidity",
  "sources": {
    "contracts/MultiSig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MultiSigWallet {\n    // Mappings:\n\n    mapping(address => bool) public doubleOwner;\n    mapping(address => mapping(uint256 => bool)) public ownerA_confirmed_TxB;\n    mapping(address => bool) public isOwner;\n    mapping(uint256 => bool) public txExecuted;\n    mapping(uint256 => uint256) public numConfirmations;\n    mapping(address => uint256) public ownerPosition;\n    // Tx Definition:\n    struct Tx {\n        address to; // To whom will the money be transfered\n        uint256 value; // The amount it will be transfered\n        address owner; // Who first proposed it\n        bool executed; // If the Tx was already executed\n        uint256 confirmations; // How many owners have confirmed it.\n        uint256 txId; // Current tx Id.\n        // For adding/removing owners and changing the numberOfConfirmations, we need the following:\n        bool changeOwners; // If yes, to becomes the to be appended or to be removed owner.\n        bool add1_del0; // If change owners, then if this is true, you wish to add. Otherwise, you remove.\n        bool changeNumConfirmations; // Change the amount of confirmations required to execute Tx.\n    }\n\n    address payable[] public owners; // Owners of the wallet\n    uint256 public minTxChecks;\n\n    constructor(address payable[] memory _owners, uint256 _initialTxChecks) {\n        // owners = _owners; - It would be ideal for gas sake, yet to ensure no invalid owners:\n\n        require(\n            _owners.length >= _initialTxChecks,\n            \"There are more txConfirmations required than signers!\"\n        );\n        require(\n            _owners.length > 0,\n            \"No address list has been passed to the constructor\"\n        );\n        require(_initialTxChecks >= 1, \"At least one owner needs to sign it!\");\n\n        for (uint256 j = 0; j < _owners.length; j++) {\n            address payable adm = _owners[j];\n            require(adm != address(0), \"Null address is invalid.\");\n            require(!doubleOwner[adm], \"There is a double address input.\");\n            doubleOwner[adm] = true; // Registration of the owner\n            ownerPosition[adm] = owners.length;\n            owners.push(adm);\n            isOwner[adm] = true;\n        }\n\n        minTxChecks = _initialTxChecks; // The initial txChecks is passed - at least this amount must be confirmed to execute.\n    }\n\n    Tx[] public txHistory;\n\n    // Modifiers:\n\n    modifier onlyOwners() {\n        require(isOwner[msg.sender], \"Not Owner - Permission Denied\");\n        _;\n    }\n\n    modifier notDoubleConfirms(uint256 txId) {\n        require(\n            !ownerA_confirmed_TxB[msg.sender][txId],\n            \"This owner has already confirmed this transaction\"\n        );\n        _;\n    }\n\n    modifier txNotExecuted(uint256 txId) {\n        require(!txExecuted[txId], \"This transaction was already executed\");\n        _;\n    }\n\n    modifier enoughConfirmations(uint256 txId) {\n        require(\n            numConfirmations[txId] >= minTxChecks,\n            \"Not enough owners have confirmed - Tx cannot execute\"\n        );\n        _;\n    }\n\n    // Functions\n    // The transaction proposed here is so that owner can propose to pay, to add/del owner or even to change the numConf.\n    /** AUDIT REQUIRED */\n    // Owner is able to change Num and Add/Del Owners at the same time...\n    // --> Essa construção de NULL e Zero tem problemas de interseção - é interessante impedir dupla ação.\n    /** ------------------ */\n    function proposeTx(\n        address payable _to,\n        uint256 _value,\n        bool _changeOwners,\n        bool _add1_del0,\n        bool _changeNumConfirmations\n    ) public onlyOwners {\n        Tx memory proposedTx = Tx({\n            to: _to,\n            value: _value,\n            owner: msg.sender,\n            executed: false,\n            confirmations: 1,\n            txId: txHistory.length,\n            changeOwners: _changeOwners,\n            add1_del0: _add1_del0,\n            changeNumConfirmations: _changeNumConfirmations // If active, to is null, value is numConf.\n        });\n        // When changing numConf, we set the to address to NULL.\n\n        /** NEEDS SOME SIGHT ON THIS TO BE SURE */\n        if (!_changeNumConfirmations) {\n            require(_to != address(0), \"No burning nor adding phantom owners.\");\n        } else {\n            proposedTx.to = address(0);\n            require(_value > 0, \"Not zero confirmations!\");\n        }\n        // When changing the Owners, we set the value to ZERO.\n        if (!_changeOwners) {\n            require(_value > 0, \"No transfer\");\n        } else {\n            proposedTx.value = 0;\n            require(_to != address(0), \"Not adding phantom owners.\");\n        }\n        /** ^^^ -------------------- ^^^  */\n        ownerA_confirmed_TxB[msg.sender][txHistory.length] = true;\n        numConfirmations[txHistory.length] += 1;\n        txHistory.push(proposedTx);\n    }\n\n    // This function must not be confirmed again by the same address.\n    function confirmTx(\n        uint256 txId\n    ) public onlyOwners notDoubleConfirms(txId) txNotExecuted(txId) {\n        txHistory[txId].confirmations += 1;\n        numConfirmations[txId] += 1;\n        ownerA_confirmed_TxB[msg.sender][txId] = true;\n    }\n\n    function deposit() public payable {}\n\n    // For withdrawing, it is the same as an usual transaction\n\n    function executeTx(\n        uint256 txId\n    )\n        public\n        onlyOwners\n        txNotExecuted(txId)\n        enoughConfirmations(txId)\n        returns (bool)\n    {\n        /** Needs AUDITING STILL  */\n        if (txHistory[txId].changeOwners) {\n            if (txHistory[txId].add1_del0) {\n                addOwner(txHistory[txId].to); // Pass the address we wish to append\n            } else {\n                removeOwner(txHistory[txId].to); // Pass the address we wish to delete\n            }\n            // require owners.length seja diferente sei la\n            return true;\n        }\n        // If the to-be-executed tx wishes to change NumConfirmations\n        if (txHistory[txId].changeNumConfirmations) {\n            changeMinChecks(txHistory[txId].value);\n        }\n        /** -----------------  */\n        // Transfer process\n        address to = txHistory[txId].to;\n        uint256 amount = txHistory[txId].value;\n        (bool success, ) = to.call{value: amount}(\"\");\n\n        // Neutralizing tx:\n        txHistory[txId].executed = true;\n        txExecuted[txId] = true;\n\n        return success;\n    }\n\n    function revokeConfirmation(\n        uint256 txId\n    ) public onlyOwners txNotExecuted(txId) {\n        require(\n            ownerA_confirmed_TxB[msg.sender][txId],\n            \"This owner did not confirm this transaction previously\"\n        );\n        txHistory[txId].confirmations -= 1;\n        ownerA_confirmed_TxB[msg.sender][txId] = false;\n    }\n\n    // Functions only to be called by the own contract, in midst other functions.\n    // We wish to take advantage of the system of transactions we have in place.\n    // These functions are the sole reason of some of parameters of a transaction.\n\n    // We do not use onlyOwners modifier since only the contract calls this function.\n    /** Needs AUDITING STILL  */\n    function addOwner(address _newOwner) internal {\n        ownerPosition[_newOwner] = owners.length; // Map the position of the new owner.\n        owners.push(payable(_newOwner)); // Append new address into the list\n    }\n\n    /** ---------------------- */\n    // This here below will be tricky....\n    /** Needs AUDITING STILL  */\n    function removeOwner(address _oldOwner) internal {\n        //uint256 index = ownerPosition[_oldOwner];\n        for (uint256 j = ownerPosition[_oldOwner]; j < owners.length - 1; j++) {\n            owners[j] = owners[j + 1];\n            ownerPosition[owners[j]] = j; // Update on position for the owner.\n        }\n        owners.pop();\n    }\n\n    /** ---------------------- */\n    function changeMinChecks(uint256 _newNumberOfConfirmations) internal {\n        minTxChecks = _newNumberOfConfirmations;\n    }\n\n    // function valueToNumConfirmations() internal onlyOwners {}\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}